/* Open Traffic Generator Testbed Model API 0.0.4
 * OTG Testbed Model
 * License: MIT */

package goopentestbed

import (
	"bytes"
	"context"
	"crypto/tls"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"strings"

	opentestbed "github.com/ANISH-GOTTAPU/goopentestbed/opentestbed"
	"github.com/ghodss/yaml"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/emptypb"
)

type versionMeta struct {
	checkVersion  bool
	localVersion  Version
	remoteVersion Version
	checkError    error
}
type goopentestbedApi struct {
	api
	grpcClient  opentestbed.OpenapiClient
	httpClient  httpClient
	versionMeta *versionMeta
}

// grpcConnect builds up a grpc connection
func (api *goopentestbedApi) grpcConnect() error {
	if api.grpcClient == nil {
		if api.grpc.clientConnection == nil {
			ctx, cancelFunc := context.WithTimeout(context.Background(), api.grpc.dialTimeout)
			defer cancelFunc()
			conn, err := grpc.DialContext(ctx, api.grpc.location, grpc.WithTransportCredentials(insecure.NewCredentials()))
			if err != nil {
				return err
			}
			api.grpcClient = opentestbed.NewOpenapiClient(conn)
			api.grpc.clientConnection = conn
		} else {
			api.grpcClient = opentestbed.NewOpenapiClient(api.grpc.clientConnection)
		}
	}
	return nil
}

func (api *goopentestbedApi) grpcClose() error {
	if api.grpc != nil {
		if api.grpc.clientConnection != nil {
			err := api.grpc.clientConnection.Close()
			if err != nil {
				return err
			}
		}
	}
	api.grpcClient = nil
	api.grpc = nil
	return nil
}

func (api *goopentestbedApi) Close() error {
	if api.hasGrpcTransport() {
		err := api.grpcClose()
		return err
	}
	if api.hasHttpTransport() {
		err := api.http.conn.(*net.TCPConn).SetLinger(0)
		api.http.conn.Close()
		api.http.conn = nil
		api.http = nil
		api.httpClient.client = nil
		return err
	}
	return nil
}

// NewApi returns a new instance of the top level interface hierarchy
func NewApi() GoopentestbedApi {
	api := goopentestbedApi{}
	api.versionMeta = &versionMeta{checkVersion: false}
	return &api
}

// httpConnect builds up a http connection
func (api *goopentestbedApi) httpConnect() error {
	if api.httpClient.client == nil {
		tr := http.Transport{
			DialTLSContext: func(ctx context.Context, network, addr string) (net.Conn, error) {
				tcpConn, err := (&net.Dialer{}).DialContext(ctx, network, addr)
				if err != nil {
					return nil, err
				}
				tlsConn := tls.Client(tcpConn, &tls.Config{InsecureSkipVerify: !api.http.verify})
				err = tlsConn.Handshake()
				if err != nil {
					return nil, err
				}
				api.http.conn = tcpConn
				return tlsConn, nil
			},
			DialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {
				tcpConn, err := (&net.Dialer{}).DialContext(ctx, network, addr)
				if err != nil {
					return nil, err
				}
				api.http.conn = tcpConn
				return tcpConn, nil
			},
		}
		client := httpClient{
			client: &http.Client{
				Transport: &tr,
			},
			ctx: context.Background(),
		}
		api.httpClient = client
	}
	return nil
}

func (api *goopentestbedApi) httpSendRecv(urlPath string, jsonBody string, method string) (*http.Response, error) {
	err := api.httpConnect()
	if err != nil {
		return nil, err
	}
	httpClient := api.httpClient
	var bodyReader = bytes.NewReader([]byte(jsonBody))
	queryUrl, err := url.Parse(api.http.location)
	if err != nil {
		return nil, err
	}
	queryUrl, _ = queryUrl.Parse(urlPath)
	req, _ := http.NewRequest(method, queryUrl.String(), bodyReader)
	req.Header.Set("Content-Type", "application/json")
	req = req.WithContext(httpClient.ctx)
	response, err := httpClient.client.Do(req)
	return response, err
}

// GoopentestbedApi oTG Testbed Model
type GoopentestbedApi interface {
	Api
	// Testbed is a container for Testbed model.
	// NewTestbed returns a new instance of Testbed.
	NewTestbed() Testbed
	// ReserveResponse is description is TBD
	// NewReserveResponse returns a new instance of ReserveResponse.
	NewReserveResponse() ReserveResponse
	// ReleaseResponse is description is TBD
	// NewReleaseResponse returns a new instance of ReleaseResponse.
	NewReleaseResponse() ReleaseResponse
	// GetVersionResponse is description is TBD
	// NewGetVersionResponse returns a new instance of GetVersionResponse.
	NewGetVersionResponse() GetVersionResponse
	// Reserve reserves the testbed based on available devices from inventory.
	Reserve(testbed Testbed) (YieldResponse, error)
	// Release releases the devices based on unique id generated during reservation.
	Release() (Warning, error)
	// GetVersion description is TBD
	GetVersion() (Version, error)
	// GetLocalVersion provides version details of local client
	GetLocalVersion() Version
	// GetRemoteVersion provides version details received from remote server
	GetRemoteVersion() (Version, error)
	// SetVersionCompatibilityCheck allows enabling or disabling automatic version
	// compatibility check between client and server API spec version upon API call
	SetVersionCompatibilityCheck(bool)
	// CheckVersionCompatibility compares API spec version for local client and remote server,
	// and returns an error if they are not compatible according to Semantic Versioning 2.0.0
	CheckVersionCompatibility() error
}

func (api *goopentestbedApi) NewTestbed() Testbed {
	return NewTestbed()
}

func (api *goopentestbedApi) NewReserveResponse() ReserveResponse {
	return NewReserveResponse()
}

func (api *goopentestbedApi) NewReleaseResponse() ReleaseResponse {
	return NewReleaseResponse()
}

func (api *goopentestbedApi) NewGetVersionResponse() GetVersionResponse {
	return NewGetVersionResponse()
}

func (api *goopentestbedApi) GetLocalVersion() Version {
	if api.versionMeta.localVersion == nil {
		api.versionMeta.localVersion = NewVersion().SetApiSpecVersion("0.0.4").SetSdkVersion("")
	}

	return api.versionMeta.localVersion
}

func (api *goopentestbedApi) GetRemoteVersion() (Version, error) {
	if api.versionMeta.remoteVersion == nil {
		v, err := api.GetVersion()
		if err != nil {
			return nil, fmt.Errorf("could not fetch remote version: %v", err)
		}

		api.versionMeta.remoteVersion = v
	}

	return api.versionMeta.remoteVersion, nil
}

func (api *goopentestbedApi) SetVersionCompatibilityCheck(v bool) {
	api.versionMeta.checkVersion = v
}

func (api *goopentestbedApi) checkLocalRemoteVersionCompatibility() (error, error) {
	localVer := api.GetLocalVersion()
	remoteVer, err := api.GetRemoteVersion()
	if err != nil {
		return nil, err
	}
	err = checkClientServerVersionCompatibility(localVer.ApiSpecVersion(), remoteVer.ApiSpecVersion(), "API spec")
	if err != nil {
		return fmt.Errorf(
			"client SDK version '%s' is not compatible with server SDK version '%s': %v",
			localVer.SdkVersion(), remoteVer.SdkVersion(), err,
		), nil
	}

	return nil, nil
}

func (api *goopentestbedApi) checkLocalRemoteVersionCompatibilityOnce() error {
	if !api.versionMeta.checkVersion {
		return nil
	}

	if api.versionMeta.checkError != nil {
		return api.versionMeta.checkError
	}

	compatErr, apiErr := api.checkLocalRemoteVersionCompatibility()
	if compatErr != nil {
		api.versionMeta.checkError = compatErr
		return compatErr
	}
	if apiErr != nil {
		api.versionMeta.checkError = nil
		return apiErr
	}

	api.versionMeta.checkVersion = false
	api.versionMeta.checkError = nil
	return nil
}

func (api *goopentestbedApi) CheckVersionCompatibility() error {
	compatErr, apiErr := api.checkLocalRemoteVersionCompatibility()
	if compatErr != nil {
		return fmt.Errorf("version error: %v", compatErr)
	}
	if apiErr != nil {
		return apiErr
	}

	return nil
}

func (api *goopentestbedApi) Reserve(testbed Testbed) (YieldResponse, error) {

	if err := testbed.Validate(); err != nil {
		return nil, err
	}

	if err := api.checkLocalRemoteVersionCompatibilityOnce(); err != nil {
		return nil, err
	}
	if api.hasHttpTransport() {
		return api.httpReserve(testbed)
	}
	if err := api.grpcConnect(); err != nil {
		return nil, err
	}
	request := opentestbed.ReserveRequest{Testbed: testbed.Msg()}
	ctx, cancelFunc := context.WithTimeout(context.Background(), api.grpc.requestTimeout)
	defer cancelFunc()
	resp, err := api.grpcClient.Reserve(ctx, &request)
	if err != nil {
		if er, ok := api.fromGrpcError(err); ok {
			return nil, er
		}
		return nil, err
	}
	ret := NewYieldResponse()
	if resp.GetYieldResponse() != nil {
		return ret.SetMsg(resp.GetYieldResponse()), nil
	}

	return ret, nil
}

func (api *goopentestbedApi) Release() (Warning, error) {

	if err := api.checkLocalRemoteVersionCompatibilityOnce(); err != nil {
		return nil, err
	}
	if api.hasHttpTransport() {
		return api.httpRelease()
	}
	if err := api.grpcConnect(); err != nil {
		return nil, err
	}
	request := emptypb.Empty{}
	ctx, cancelFunc := context.WithTimeout(context.Background(), api.grpc.requestTimeout)
	defer cancelFunc()
	resp, err := api.grpcClient.Release(ctx, &request)
	if err != nil {
		if er, ok := api.fromGrpcError(err); ok {
			return nil, er
		}
		return nil, err
	}
	ret := NewWarning()
	if resp.GetWarning() != nil {
		return ret.SetMsg(resp.GetWarning()), nil
	}

	return ret, nil
}

func (api *goopentestbedApi) GetVersion() (Version, error) {

	if api.hasHttpTransport() {
		return api.httpGetVersion()
	}
	if err := api.grpcConnect(); err != nil {
		return nil, err
	}
	request := emptypb.Empty{}
	ctx, cancelFunc := context.WithTimeout(context.Background(), api.grpc.requestTimeout)
	defer cancelFunc()
	resp, err := api.grpcClient.GetVersion(ctx, &request)
	if err != nil {
		if er, ok := api.fromGrpcError(err); ok {
			return nil, er
		}
		return nil, err
	}
	ret := NewVersion()
	if resp.GetVersion() != nil {
		return ret.SetMsg(resp.GetVersion()), nil
	}

	return ret, nil
}

func (api *goopentestbedApi) httpReserve(testbed Testbed) (YieldResponse, error) {
	testbedJson, err := testbed.ToJson()
	if err != nil {
		return nil, err
	}
	resp, err := api.httpSendRecv("reserve", testbedJson, "POST")

	if err != nil {
		return nil, err
	}
	bodyBytes, err := io.ReadAll(resp.Body)
	defer resp.Body.Close()
	if err != nil {
		return nil, err
	}
	if resp.StatusCode == 200 {
		obj := api.NewReserveResponse().YieldResponse()
		if err := obj.FromJson(string(bodyBytes)); err != nil {
			return nil, err
		}
		return obj, nil
	} else {
		return nil, api.fromHttpError(resp.StatusCode, bodyBytes)
	}
}

func (api *goopentestbedApi) httpRelease() (Warning, error) {
	resp, err := api.httpSendRecv("release", "", "POST")
	if err != nil {
		return nil, err
	}
	bodyBytes, err := io.ReadAll(resp.Body)
	defer resp.Body.Close()
	if err != nil {
		return nil, err
	}
	if resp.StatusCode == 200 {
		obj := api.NewReleaseResponse().Warning()
		if err := obj.FromJson(string(bodyBytes)); err != nil {
			return nil, err
		}
		return obj, nil
	} else {
		return nil, api.fromHttpError(resp.StatusCode, bodyBytes)
	}
}

func (api *goopentestbedApi) httpGetVersion() (Version, error) {
	resp, err := api.httpSendRecv("capabilities/version", "", "GET")
	if err != nil {
		return nil, err
	}
	bodyBytes, err := io.ReadAll(resp.Body)
	defer resp.Body.Close()
	if err != nil {
		return nil, err
	}
	if resp.StatusCode == 200 {
		obj := api.NewGetVersionResponse().Version()
		if err := obj.FromJson(string(bodyBytes)); err != nil {
			return nil, err
		}
		return obj, nil
	} else {
		return nil, api.fromHttpError(resp.StatusCode, bodyBytes)
	}
}

// ***** Testbed *****
type testbed struct {
	validation
	obj           *opentestbed.Testbed
	devicesHolder TestbedDeviceIter
	linksHolder   TestbedLinkIter
}

func NewTestbed() Testbed {
	obj := testbed{obj: &opentestbed.Testbed{}}
	obj.setDefault()
	return &obj
}

func (obj *testbed) Msg() *opentestbed.Testbed {
	return obj.obj
}

func (obj *testbed) SetMsg(msg *opentestbed.Testbed) Testbed {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *testbed) ToProto() (*opentestbed.Testbed, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *testbed) FromProto(msg *opentestbed.Testbed) (Testbed, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *testbed) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *testbed) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *testbed) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *testbed) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *testbed) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *testbed) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *testbed) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *testbed) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *testbed) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *testbed) Clone() (Testbed, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewTestbed()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *testbed) setNil() {
	obj.devicesHolder = nil
	obj.linksHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// Testbed is a container for Testbed model.
type Testbed interface {
	Validation
	// Msg marshals Testbed to protobuf object *opentestbed.Testbed
	// and doesn't set defaults
	Msg() *opentestbed.Testbed
	// SetMsg unmarshals Testbed from protobuf object *opentestbed.Testbed
	// and doesn't set defaults
	SetMsg(*opentestbed.Testbed) Testbed
	// ToProto marshals Testbed to protobuf object *opentestbed.Testbed
	ToProto() (*opentestbed.Testbed, error)
	// ToPbText marshals Testbed to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Testbed to YAML text
	ToYaml() (string, error)
	// ToJson marshals Testbed to JSON text
	ToJson() (string, error)
	// FromProto unmarshals Testbed from protobuf object *opentestbed.Testbed
	FromProto(msg *opentestbed.Testbed) (Testbed, error)
	// FromPbText unmarshals Testbed from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Testbed from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Testbed from JSON text
	FromJson(value string) error
	// Validate validates Testbed
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Testbed, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Devices returns TestbedDeviceIterIter, set in Testbed
	Devices() TestbedDeviceIter
	// Links returns TestbedLinkIterIter, set in Testbed
	Links() TestbedLinkIter
	setNil()
}

// Logical Device with list of logical ports
// Devices returns a []Device
func (obj *testbed) Devices() TestbedDeviceIter {
	if len(obj.obj.Devices) == 0 {
		obj.obj.Devices = []*opentestbed.Device{}
	}
	if obj.devicesHolder == nil {
		obj.devicesHolder = newTestbedDeviceIter(&obj.obj.Devices).setMsg(obj)
	}
	return obj.devicesHolder
}

type testbedDeviceIter struct {
	obj         *testbed
	deviceSlice []Device
	fieldPtr    *[]*opentestbed.Device
}

func newTestbedDeviceIter(ptr *[]*opentestbed.Device) TestbedDeviceIter {
	return &testbedDeviceIter{fieldPtr: ptr}
}

type TestbedDeviceIter interface {
	setMsg(*testbed) TestbedDeviceIter
	Items() []Device
	Add() Device
	Append(items ...Device) TestbedDeviceIter
	Set(index int, newObj Device) TestbedDeviceIter
	Clear() TestbedDeviceIter
	clearHolderSlice() TestbedDeviceIter
	appendHolderSlice(item Device) TestbedDeviceIter
}

func (obj *testbedDeviceIter) setMsg(msg *testbed) TestbedDeviceIter {
	obj.clearHolderSlice()
	for _, val := range *obj.fieldPtr {
		obj.appendHolderSlice(&device{obj: val})
	}
	obj.obj = msg
	return obj
}

func (obj *testbedDeviceIter) Items() []Device {
	return obj.deviceSlice
}

func (obj *testbedDeviceIter) Add() Device {
	newObj := &opentestbed.Device{}
	*obj.fieldPtr = append(*obj.fieldPtr, newObj)
	newLibObj := &device{obj: newObj}
	newLibObj.setDefault()
	obj.deviceSlice = append(obj.deviceSlice, newLibObj)
	return newLibObj
}

func (obj *testbedDeviceIter) Append(items ...Device) TestbedDeviceIter {
	for _, item := range items {
		newObj := item.Msg()
		*obj.fieldPtr = append(*obj.fieldPtr, newObj)
		obj.deviceSlice = append(obj.deviceSlice, item)
	}
	return obj
}

func (obj *testbedDeviceIter) Set(index int, newObj Device) TestbedDeviceIter {
	(*obj.fieldPtr)[index] = newObj.Msg()
	obj.deviceSlice[index] = newObj
	return obj
}
func (obj *testbedDeviceIter) Clear() TestbedDeviceIter {
	if len(*obj.fieldPtr) > 0 {
		*obj.fieldPtr = []*opentestbed.Device{}
		obj.deviceSlice = []Device{}
	}
	return obj
}
func (obj *testbedDeviceIter) clearHolderSlice() TestbedDeviceIter {
	if len(obj.deviceSlice) > 0 {
		obj.deviceSlice = []Device{}
	}
	return obj
}
func (obj *testbedDeviceIter) appendHolderSlice(item Device) TestbedDeviceIter {
	obj.deviceSlice = append(obj.deviceSlice, item)
	return obj
}

// Interconnection of logical ports between logical devices.
// Links returns a []Link
func (obj *testbed) Links() TestbedLinkIter {
	if len(obj.obj.Links) == 0 {
		obj.obj.Links = []*opentestbed.Link{}
	}
	if obj.linksHolder == nil {
		obj.linksHolder = newTestbedLinkIter(&obj.obj.Links).setMsg(obj)
	}
	return obj.linksHolder
}

type testbedLinkIter struct {
	obj       *testbed
	linkSlice []Link
	fieldPtr  *[]*opentestbed.Link
}

func newTestbedLinkIter(ptr *[]*opentestbed.Link) TestbedLinkIter {
	return &testbedLinkIter{fieldPtr: ptr}
}

type TestbedLinkIter interface {
	setMsg(*testbed) TestbedLinkIter
	Items() []Link
	Add() Link
	Append(items ...Link) TestbedLinkIter
	Set(index int, newObj Link) TestbedLinkIter
	Clear() TestbedLinkIter
	clearHolderSlice() TestbedLinkIter
	appendHolderSlice(item Link) TestbedLinkIter
}

func (obj *testbedLinkIter) setMsg(msg *testbed) TestbedLinkIter {
	obj.clearHolderSlice()
	for _, val := range *obj.fieldPtr {
		obj.appendHolderSlice(&link{obj: val})
	}
	obj.obj = msg
	return obj
}

func (obj *testbedLinkIter) Items() []Link {
	return obj.linkSlice
}

func (obj *testbedLinkIter) Add() Link {
	newObj := &opentestbed.Link{}
	*obj.fieldPtr = append(*obj.fieldPtr, newObj)
	newLibObj := &link{obj: newObj}
	newLibObj.setDefault()
	obj.linkSlice = append(obj.linkSlice, newLibObj)
	return newLibObj
}

func (obj *testbedLinkIter) Append(items ...Link) TestbedLinkIter {
	for _, item := range items {
		newObj := item.Msg()
		*obj.fieldPtr = append(*obj.fieldPtr, newObj)
		obj.linkSlice = append(obj.linkSlice, item)
	}
	return obj
}

func (obj *testbedLinkIter) Set(index int, newObj Link) TestbedLinkIter {
	(*obj.fieldPtr)[index] = newObj.Msg()
	obj.linkSlice[index] = newObj
	return obj
}
func (obj *testbedLinkIter) Clear() TestbedLinkIter {
	if len(*obj.fieldPtr) > 0 {
		*obj.fieldPtr = []*opentestbed.Link{}
		obj.linkSlice = []Link{}
	}
	return obj
}
func (obj *testbedLinkIter) clearHolderSlice() TestbedLinkIter {
	if len(obj.linkSlice) > 0 {
		obj.linkSlice = []Link{}
	}
	return obj
}
func (obj *testbedLinkIter) appendHolderSlice(item Link) TestbedLinkIter {
	obj.linkSlice = append(obj.linkSlice, item)
	return obj
}

func (obj *testbed) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	if len(obj.obj.Devices) != 0 {

		if set_default {
			obj.Devices().clearHolderSlice()
			for _, item := range obj.obj.Devices {
				obj.Devices().appendHolderSlice(&device{obj: item})
			}
		}
		for _, item := range obj.Devices().Items() {
			item.validateObj(vObj, set_default)
		}

	}

	if len(obj.obj.Links) != 0 {

		if set_default {
			obj.Links().clearHolderSlice()
			for _, item := range obj.obj.Links {
				obj.Links().appendHolderSlice(&link{obj: item})
			}
		}
		for _, item := range obj.Links().Items() {
			item.validateObj(vObj, set_default)
		}

	}

}

func (obj *testbed) setDefault() {

}

// ***** ReserveResponse *****
type reserveResponse struct {
	validation
	obj                 *opentestbed.ReserveResponse
	yieldResponseHolder YieldResponse
}

func NewReserveResponse() ReserveResponse {
	obj := reserveResponse{obj: &opentestbed.ReserveResponse{}}
	obj.setDefault()
	return &obj
}

func (obj *reserveResponse) Msg() *opentestbed.ReserveResponse {
	return obj.obj
}

func (obj *reserveResponse) SetMsg(msg *opentestbed.ReserveResponse) ReserveResponse {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *reserveResponse) ToProto() (*opentestbed.ReserveResponse, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *reserveResponse) FromProto(msg *opentestbed.ReserveResponse) (ReserveResponse, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *reserveResponse) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *reserveResponse) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *reserveResponse) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *reserveResponse) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *reserveResponse) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *reserveResponse) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *reserveResponse) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *reserveResponse) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *reserveResponse) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *reserveResponse) Clone() (ReserveResponse, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewReserveResponse()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *reserveResponse) setNil() {
	obj.yieldResponseHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// ReserveResponse is description is TBD
type ReserveResponse interface {
	Validation
	// Msg marshals ReserveResponse to protobuf object *opentestbed.ReserveResponse
	// and doesn't set defaults
	Msg() *opentestbed.ReserveResponse
	// SetMsg unmarshals ReserveResponse from protobuf object *opentestbed.ReserveResponse
	// and doesn't set defaults
	SetMsg(*opentestbed.ReserveResponse) ReserveResponse
	// ToProto marshals ReserveResponse to protobuf object *opentestbed.ReserveResponse
	ToProto() (*opentestbed.ReserveResponse, error)
	// ToPbText marshals ReserveResponse to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals ReserveResponse to YAML text
	ToYaml() (string, error)
	// ToJson marshals ReserveResponse to JSON text
	ToJson() (string, error)
	// FromProto unmarshals ReserveResponse from protobuf object *opentestbed.ReserveResponse
	FromProto(msg *opentestbed.ReserveResponse) (ReserveResponse, error)
	// FromPbText unmarshals ReserveResponse from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals ReserveResponse from YAML text
	FromYaml(value string) error
	// FromJson unmarshals ReserveResponse from JSON text
	FromJson(value string) error
	// Validate validates ReserveResponse
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (ReserveResponse, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// YieldResponse returns YieldResponse, set in ReserveResponse.
	// YieldResponse is output Response
	YieldResponse() YieldResponse
	// SetYieldResponse assigns YieldResponse provided by user to ReserveResponse.
	// YieldResponse is output Response
	SetYieldResponse(value YieldResponse) ReserveResponse
	// HasYieldResponse checks if YieldResponse has been set in ReserveResponse
	HasYieldResponse() bool
	setNil()
}

// description is TBD
// YieldResponse returns a YieldResponse
func (obj *reserveResponse) YieldResponse() YieldResponse {
	if obj.obj.YieldResponse == nil {
		obj.obj.YieldResponse = NewYieldResponse().Msg()
	}
	if obj.yieldResponseHolder == nil {
		obj.yieldResponseHolder = &yieldResponse{obj: obj.obj.YieldResponse}
	}
	return obj.yieldResponseHolder
}

// description is TBD
// YieldResponse returns a YieldResponse
func (obj *reserveResponse) HasYieldResponse() bool {
	return obj.obj.YieldResponse != nil
}

// description is TBD
// SetYieldResponse sets the YieldResponse value in the ReserveResponse object
func (obj *reserveResponse) SetYieldResponse(value YieldResponse) ReserveResponse {

	obj.yieldResponseHolder = nil
	obj.obj.YieldResponse = value.Msg()

	return obj
}

func (obj *reserveResponse) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	if obj.obj.YieldResponse != nil {

		obj.YieldResponse().validateObj(vObj, set_default)
	}

}

func (obj *reserveResponse) setDefault() {

}

// ***** ReleaseResponse *****
type releaseResponse struct {
	validation
	obj           *opentestbed.ReleaseResponse
	warningHolder Warning
}

func NewReleaseResponse() ReleaseResponse {
	obj := releaseResponse{obj: &opentestbed.ReleaseResponse{}}
	obj.setDefault()
	return &obj
}

func (obj *releaseResponse) Msg() *opentestbed.ReleaseResponse {
	return obj.obj
}

func (obj *releaseResponse) SetMsg(msg *opentestbed.ReleaseResponse) ReleaseResponse {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *releaseResponse) ToProto() (*opentestbed.ReleaseResponse, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *releaseResponse) FromProto(msg *opentestbed.ReleaseResponse) (ReleaseResponse, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *releaseResponse) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *releaseResponse) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *releaseResponse) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *releaseResponse) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *releaseResponse) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *releaseResponse) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *releaseResponse) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *releaseResponse) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *releaseResponse) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *releaseResponse) Clone() (ReleaseResponse, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewReleaseResponse()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *releaseResponse) setNil() {
	obj.warningHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// ReleaseResponse is description is TBD
type ReleaseResponse interface {
	Validation
	// Msg marshals ReleaseResponse to protobuf object *opentestbed.ReleaseResponse
	// and doesn't set defaults
	Msg() *opentestbed.ReleaseResponse
	// SetMsg unmarshals ReleaseResponse from protobuf object *opentestbed.ReleaseResponse
	// and doesn't set defaults
	SetMsg(*opentestbed.ReleaseResponse) ReleaseResponse
	// ToProto marshals ReleaseResponse to protobuf object *opentestbed.ReleaseResponse
	ToProto() (*opentestbed.ReleaseResponse, error)
	// ToPbText marshals ReleaseResponse to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals ReleaseResponse to YAML text
	ToYaml() (string, error)
	// ToJson marshals ReleaseResponse to JSON text
	ToJson() (string, error)
	// FromProto unmarshals ReleaseResponse from protobuf object *opentestbed.ReleaseResponse
	FromProto(msg *opentestbed.ReleaseResponse) (ReleaseResponse, error)
	// FromPbText unmarshals ReleaseResponse from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals ReleaseResponse from YAML text
	FromYaml(value string) error
	// FromJson unmarshals ReleaseResponse from JSON text
	FromJson(value string) error
	// Validate validates ReleaseResponse
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (ReleaseResponse, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Warning returns Warning, set in ReleaseResponse.
	// Warning is a list of warnings that have occurred while executing the request.
	Warning() Warning
	// SetWarning assigns Warning provided by user to ReleaseResponse.
	// Warning is a list of warnings that have occurred while executing the request.
	SetWarning(value Warning) ReleaseResponse
	// HasWarning checks if Warning has been set in ReleaseResponse
	HasWarning() bool
	setNil()
}

// description is TBD
// Warning returns a Warning
func (obj *releaseResponse) Warning() Warning {
	if obj.obj.Warning == nil {
		obj.obj.Warning = NewWarning().Msg()
	}
	if obj.warningHolder == nil {
		obj.warningHolder = &warning{obj: obj.obj.Warning}
	}
	return obj.warningHolder
}

// description is TBD
// Warning returns a Warning
func (obj *releaseResponse) HasWarning() bool {
	return obj.obj.Warning != nil
}

// description is TBD
// SetWarning sets the Warning value in the ReleaseResponse object
func (obj *releaseResponse) SetWarning(value Warning) ReleaseResponse {

	obj.warningHolder = nil
	obj.obj.Warning = value.Msg()

	return obj
}

func (obj *releaseResponse) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	if obj.obj.Warning != nil {

		obj.Warning().validateObj(vObj, set_default)
	}

}

func (obj *releaseResponse) setDefault() {

}

// ***** GetVersionResponse *****
type getVersionResponse struct {
	validation
	obj           *opentestbed.GetVersionResponse
	versionHolder Version
}

func NewGetVersionResponse() GetVersionResponse {
	obj := getVersionResponse{obj: &opentestbed.GetVersionResponse{}}
	obj.setDefault()
	return &obj
}

func (obj *getVersionResponse) Msg() *opentestbed.GetVersionResponse {
	return obj.obj
}

func (obj *getVersionResponse) SetMsg(msg *opentestbed.GetVersionResponse) GetVersionResponse {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *getVersionResponse) ToProto() (*opentestbed.GetVersionResponse, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *getVersionResponse) FromProto(msg *opentestbed.GetVersionResponse) (GetVersionResponse, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *getVersionResponse) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *getVersionResponse) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *getVersionResponse) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *getVersionResponse) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *getVersionResponse) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *getVersionResponse) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *getVersionResponse) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *getVersionResponse) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *getVersionResponse) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *getVersionResponse) Clone() (GetVersionResponse, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewGetVersionResponse()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *getVersionResponse) setNil() {
	obj.versionHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// GetVersionResponse is description is TBD
type GetVersionResponse interface {
	Validation
	// Msg marshals GetVersionResponse to protobuf object *opentestbed.GetVersionResponse
	// and doesn't set defaults
	Msg() *opentestbed.GetVersionResponse
	// SetMsg unmarshals GetVersionResponse from protobuf object *opentestbed.GetVersionResponse
	// and doesn't set defaults
	SetMsg(*opentestbed.GetVersionResponse) GetVersionResponse
	// ToProto marshals GetVersionResponse to protobuf object *opentestbed.GetVersionResponse
	ToProto() (*opentestbed.GetVersionResponse, error)
	// ToPbText marshals GetVersionResponse to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals GetVersionResponse to YAML text
	ToYaml() (string, error)
	// ToJson marshals GetVersionResponse to JSON text
	ToJson() (string, error)
	// FromProto unmarshals GetVersionResponse from protobuf object *opentestbed.GetVersionResponse
	FromProto(msg *opentestbed.GetVersionResponse) (GetVersionResponse, error)
	// FromPbText unmarshals GetVersionResponse from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals GetVersionResponse from YAML text
	FromYaml(value string) error
	// FromJson unmarshals GetVersionResponse from JSON text
	FromJson(value string) error
	// Validate validates GetVersionResponse
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (GetVersionResponse, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Version returns Version, set in GetVersionResponse.
	// Version is version details
	Version() Version
	// SetVersion assigns Version provided by user to GetVersionResponse.
	// Version is version details
	SetVersion(value Version) GetVersionResponse
	// HasVersion checks if Version has been set in GetVersionResponse
	HasVersion() bool
	setNil()
}

// description is TBD
// Version returns a Version
func (obj *getVersionResponse) Version() Version {
	if obj.obj.Version == nil {
		obj.obj.Version = NewVersion().Msg()
	}
	if obj.versionHolder == nil {
		obj.versionHolder = &version{obj: obj.obj.Version}
	}
	return obj.versionHolder
}

// description is TBD
// Version returns a Version
func (obj *getVersionResponse) HasVersion() bool {
	return obj.obj.Version != nil
}

// description is TBD
// SetVersion sets the Version value in the GetVersionResponse object
func (obj *getVersionResponse) SetVersion(value Version) GetVersionResponse {

	obj.versionHolder = nil
	obj.obj.Version = value.Msg()

	return obj
}

func (obj *getVersionResponse) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	if obj.obj.Version != nil {

		obj.Version().validateObj(vObj, set_default)
	}

}

func (obj *getVersionResponse) setDefault() {

}

// ***** Device *****
type device struct {
	validation
	obj              *opentestbed.Device
	portsHolder      DevicePortIter
	attributesHolder DeviceAttributeIter
}

func NewDevice() Device {
	obj := device{obj: &opentestbed.Device{}}
	obj.setDefault()
	return &obj
}

func (obj *device) Msg() *opentestbed.Device {
	return obj.obj
}

func (obj *device) SetMsg(msg *opentestbed.Device) Device {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *device) ToProto() (*opentestbed.Device, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *device) FromProto(msg *opentestbed.Device) (Device, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *device) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *device) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *device) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *device) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *device) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *device) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *device) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *device) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *device) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *device) Clone() (Device, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewDevice()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *device) setNil() {
	obj.portsHolder = nil
	obj.attributesHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// Device is device.
type Device interface {
	Validation
	// Msg marshals Device to protobuf object *opentestbed.Device
	// and doesn't set defaults
	Msg() *opentestbed.Device
	// SetMsg unmarshals Device from protobuf object *opentestbed.Device
	// and doesn't set defaults
	SetMsg(*opentestbed.Device) Device
	// ToProto marshals Device to protobuf object *opentestbed.Device
	ToProto() (*opentestbed.Device, error)
	// ToPbText marshals Device to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Device to YAML text
	ToYaml() (string, error)
	// ToJson marshals Device to JSON text
	ToJson() (string, error)
	// FromProto unmarshals Device from protobuf object *opentestbed.Device
	FromProto(msg *opentestbed.Device) (Device, error)
	// FromPbText unmarshals Device from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Device from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Device from JSON text
	FromJson(value string) error
	// Validate validates Device
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Device, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Id returns string, set in Device.
	Id() string
	// SetId assigns string provided by user to Device
	SetId(value string) Device
	// Name returns string, set in Device.
	Name() string
	// SetName assigns string provided by user to Device
	SetName(value string) Device
	// HasName checks if Name has been set in Device
	HasName() bool
	// Vendor returns string, set in Device.
	Vendor() string
	// SetVendor assigns string provided by user to Device
	SetVendor(value string) Device
	// HasVendor checks if Vendor has been set in Device
	HasVendor() bool
	// Model returns string, set in Device.
	Model() string
	// SetModel assigns string provided by user to Device
	SetModel(value string) Device
	// HasModel checks if Model has been set in Device
	HasModel() bool
	// Platform returns string, set in Device.
	Platform() string
	// SetPlatform assigns string provided by user to Device
	SetPlatform(value string) Device
	// HasPlatform checks if Platform has been set in Device
	HasPlatform() bool
	// Image returns string, set in Device.
	Image() string
	// SetImage assigns string provided by user to Device
	SetImage(value string) Device
	// HasImage checks if Image has been set in Device
	HasImage() bool
	// Ports returns DevicePortIterIter, set in Device
	Ports() DevicePortIter
	// Attributes returns DeviceAttributeIterIter, set in Device
	Attributes() DeviceAttributeIter
	// Role returns DeviceRoleEnum, set in Device
	Role() DeviceRoleEnum
	// SetRole assigns DeviceRoleEnum provided by user to Device
	SetRole(value DeviceRoleEnum) Device
	setNil()
}

// Globally unique id of an object. It also serves as the primary key for arrays of objects.
// Id returns a string
func (obj *device) Id() string {

	return *obj.obj.Id

}

// Globally unique id of an object. It also serves as the primary key for arrays of objects.
// SetId sets the string value in the Device object
func (obj *device) SetId(value string) Device {

	obj.obj.Id = &value
	return obj
}

// Name of the device that you want to match from the inventory
// Name returns a string
func (obj *device) Name() string {

	return *obj.obj.Name

}

// Name of the device that you want to match from the inventory
// Name returns a string
func (obj *device) HasName() bool {
	return obj.obj.Name != nil
}

// Name of the device that you want to match from the inventory
// SetName sets the string value in the Device object
func (obj *device) SetName(value string) Device {

	obj.obj.Name = &value
	return obj
}

// Vendor(manufacturer of the device)
// Vendor returns a string
func (obj *device) Vendor() string {

	return *obj.obj.Vendor

}

// Vendor(manufacturer of the device)
// Vendor returns a string
func (obj *device) HasVendor() bool {
	return obj.obj.Vendor != nil
}

// Vendor(manufacturer of the device)
// SetVendor sets the string value in the Device object
func (obj *device) SetVendor(value string) Device {

	obj.obj.Vendor = &value
	return obj
}

// Model(unique identification of the device type)
// Model returns a string
func (obj *device) Model() string {

	return *obj.obj.Model

}

// Model(unique identification of the device type)
// Model returns a string
func (obj *device) HasModel() bool {
	return obj.obj.Model != nil
}

// Model(unique identification of the device type)
// SetModel sets the string value in the Device object
func (obj *device) SetModel(value string) Device {

	obj.obj.Model = &value
	return obj
}

// Platform (describes a combination of operating system, applications, or other types of software that is supported by the device)
// Platform returns a string
func (obj *device) Platform() string {

	return *obj.obj.Platform

}

// Platform (describes a combination of operating system, applications, or other types of software that is supported by the device)
// Platform returns a string
func (obj *device) HasPlatform() bool {
	return obj.obj.Platform != nil
}

// Platform (describes a combination of operating system, applications, or other types of software that is supported by the device)
// SetPlatform sets the string value in the Device object
func (obj *device) SetPlatform(value string) Device {

	obj.obj.Platform = &value
	return obj
}

// Image (a unique software package installed on the device)
// Image returns a string
func (obj *device) Image() string {

	return *obj.obj.Image

}

// Image (a unique software package installed on the device)
// Image returns a string
func (obj *device) HasImage() bool {
	return obj.obj.Image != nil
}

// Image (a unique software package installed on the device)
// SetImage sets the string value in the Device object
func (obj *device) SetImage(value string) Device {

	obj.obj.Image = &value
	return obj
}

// List of Logical ports
// Ports returns a []Port
func (obj *device) Ports() DevicePortIter {
	if len(obj.obj.Ports) == 0 {
		obj.obj.Ports = []*opentestbed.Port{}
	}
	if obj.portsHolder == nil {
		obj.portsHolder = newDevicePortIter(&obj.obj.Ports).setMsg(obj)
	}
	return obj.portsHolder
}

type devicePortIter struct {
	obj       *device
	portSlice []Port
	fieldPtr  *[]*opentestbed.Port
}

func newDevicePortIter(ptr *[]*opentestbed.Port) DevicePortIter {
	return &devicePortIter{fieldPtr: ptr}
}

type DevicePortIter interface {
	setMsg(*device) DevicePortIter
	Items() []Port
	Add() Port
	Append(items ...Port) DevicePortIter
	Set(index int, newObj Port) DevicePortIter
	Clear() DevicePortIter
	clearHolderSlice() DevicePortIter
	appendHolderSlice(item Port) DevicePortIter
}

func (obj *devicePortIter) setMsg(msg *device) DevicePortIter {
	obj.clearHolderSlice()
	for _, val := range *obj.fieldPtr {
		obj.appendHolderSlice(&port{obj: val})
	}
	obj.obj = msg
	return obj
}

func (obj *devicePortIter) Items() []Port {
	return obj.portSlice
}

func (obj *devicePortIter) Add() Port {
	newObj := &opentestbed.Port{}
	*obj.fieldPtr = append(*obj.fieldPtr, newObj)
	newLibObj := &port{obj: newObj}
	newLibObj.setDefault()
	obj.portSlice = append(obj.portSlice, newLibObj)
	return newLibObj
}

func (obj *devicePortIter) Append(items ...Port) DevicePortIter {
	for _, item := range items {
		newObj := item.Msg()
		*obj.fieldPtr = append(*obj.fieldPtr, newObj)
		obj.portSlice = append(obj.portSlice, item)
	}
	return obj
}

func (obj *devicePortIter) Set(index int, newObj Port) DevicePortIter {
	(*obj.fieldPtr)[index] = newObj.Msg()
	obj.portSlice[index] = newObj
	return obj
}
func (obj *devicePortIter) Clear() DevicePortIter {
	if len(*obj.fieldPtr) > 0 {
		*obj.fieldPtr = []*opentestbed.Port{}
		obj.portSlice = []Port{}
	}
	return obj
}
func (obj *devicePortIter) clearHolderSlice() DevicePortIter {
	if len(obj.portSlice) > 0 {
		obj.portSlice = []Port{}
	}
	return obj
}
func (obj *devicePortIter) appendHolderSlice(item Port) DevicePortIter {
	obj.portSlice = append(obj.portSlice, item)
	return obj
}

// attributes of the devices
// Attributes returns a []Attribute
func (obj *device) Attributes() DeviceAttributeIter {
	if len(obj.obj.Attributes) == 0 {
		obj.obj.Attributes = []*opentestbed.Attribute{}
	}
	if obj.attributesHolder == nil {
		obj.attributesHolder = newDeviceAttributeIter(&obj.obj.Attributes).setMsg(obj)
	}
	return obj.attributesHolder
}

type deviceAttributeIter struct {
	obj            *device
	attributeSlice []Attribute
	fieldPtr       *[]*opentestbed.Attribute
}

func newDeviceAttributeIter(ptr *[]*opentestbed.Attribute) DeviceAttributeIter {
	return &deviceAttributeIter{fieldPtr: ptr}
}

type DeviceAttributeIter interface {
	setMsg(*device) DeviceAttributeIter
	Items() []Attribute
	Add() Attribute
	Append(items ...Attribute) DeviceAttributeIter
	Set(index int, newObj Attribute) DeviceAttributeIter
	Clear() DeviceAttributeIter
	clearHolderSlice() DeviceAttributeIter
	appendHolderSlice(item Attribute) DeviceAttributeIter
}

func (obj *deviceAttributeIter) setMsg(msg *device) DeviceAttributeIter {
	obj.clearHolderSlice()
	for _, val := range *obj.fieldPtr {
		obj.appendHolderSlice(&attribute{obj: val})
	}
	obj.obj = msg
	return obj
}

func (obj *deviceAttributeIter) Items() []Attribute {
	return obj.attributeSlice
}

func (obj *deviceAttributeIter) Add() Attribute {
	newObj := &opentestbed.Attribute{}
	*obj.fieldPtr = append(*obj.fieldPtr, newObj)
	newLibObj := &attribute{obj: newObj}
	newLibObj.setDefault()
	obj.attributeSlice = append(obj.attributeSlice, newLibObj)
	return newLibObj
}

func (obj *deviceAttributeIter) Append(items ...Attribute) DeviceAttributeIter {
	for _, item := range items {
		newObj := item.Msg()
		*obj.fieldPtr = append(*obj.fieldPtr, newObj)
		obj.attributeSlice = append(obj.attributeSlice, item)
	}
	return obj
}

func (obj *deviceAttributeIter) Set(index int, newObj Attribute) DeviceAttributeIter {
	(*obj.fieldPtr)[index] = newObj.Msg()
	obj.attributeSlice[index] = newObj
	return obj
}
func (obj *deviceAttributeIter) Clear() DeviceAttributeIter {
	if len(*obj.fieldPtr) > 0 {
		*obj.fieldPtr = []*opentestbed.Attribute{}
		obj.attributeSlice = []Attribute{}
	}
	return obj
}
func (obj *deviceAttributeIter) clearHolderSlice() DeviceAttributeIter {
	if len(obj.attributeSlice) > 0 {
		obj.attributeSlice = []Attribute{}
	}
	return obj
}
func (obj *deviceAttributeIter) appendHolderSlice(item Attribute) DeviceAttributeIter {
	obj.attributeSlice = append(obj.attributeSlice, item)
	return obj
}

type DeviceRoleEnum string

// Enum of Role on Device
var DeviceRole = struct {
	DUT DeviceRoleEnum
	ATE DeviceRoleEnum
	L1S DeviceRoleEnum
}{
	DUT: DeviceRoleEnum("DUT"),
	ATE: DeviceRoleEnum("ATE"),
	L1S: DeviceRoleEnum("L1S"),
}

func (obj *device) Role() DeviceRoleEnum {
	return DeviceRoleEnum(obj.obj.Role.Enum().String())
}

func (obj *device) SetRole(value DeviceRoleEnum) Device {
	intValue, ok := opentestbed.Device_Role_Enum_value[string(value)]
	if !ok {
		obj.validationErrors = append(obj.validationErrors, fmt.Sprintf(
			"%s is not a valid choice on DeviceRoleEnum", string(value)))
		return obj
	}
	enumValue := opentestbed.Device_Role_Enum(intValue)
	obj.obj.Role = &enumValue

	return obj
}

func (obj *device) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	// Id is required
	if obj.obj.Id == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Id is required field on interface Device")
	}

	if len(obj.obj.Ports) != 0 {

		if set_default {
			obj.Ports().clearHolderSlice()
			for _, item := range obj.obj.Ports {
				obj.Ports().appendHolderSlice(&port{obj: item})
			}
		}
		for _, item := range obj.Ports().Items() {
			item.validateObj(vObj, set_default)
		}

	}

	if len(obj.obj.Attributes) != 0 {

		if set_default {
			obj.Attributes().clearHolderSlice()
			for _, item := range obj.obj.Attributes {
				obj.Attributes().appendHolderSlice(&attribute{obj: item})
			}
		}
		for _, item := range obj.Attributes().Items() {
			item.validateObj(vObj, set_default)
		}

	}

	// Role is required
	if obj.obj.Role == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Role is required field on interface Device")
	}
}

func (obj *device) setDefault() {

}

// ***** Link *****
type link struct {
	validation
	obj       *opentestbed.Link
	srcHolder LinkSrc
	dstHolder LinkDst
}

func NewLink() Link {
	obj := link{obj: &opentestbed.Link{}}
	obj.setDefault()
	return &obj
}

func (obj *link) Msg() *opentestbed.Link {
	return obj.obj
}

func (obj *link) SetMsg(msg *opentestbed.Link) Link {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *link) ToProto() (*opentestbed.Link, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *link) FromProto(msg *opentestbed.Link) (Link, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *link) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *link) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *link) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *link) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *link) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *link) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *link) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *link) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *link) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *link) Clone() (Link, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewLink()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *link) setNil() {
	obj.srcHolder = nil
	obj.dstHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// Link is device.
type Link interface {
	Validation
	// Msg marshals Link to protobuf object *opentestbed.Link
	// and doesn't set defaults
	Msg() *opentestbed.Link
	// SetMsg unmarshals Link from protobuf object *opentestbed.Link
	// and doesn't set defaults
	SetMsg(*opentestbed.Link) Link
	// ToProto marshals Link to protobuf object *opentestbed.Link
	ToProto() (*opentestbed.Link, error)
	// ToPbText marshals Link to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Link to YAML text
	ToYaml() (string, error)
	// ToJson marshals Link to JSON text
	ToJson() (string, error)
	// FromProto unmarshals Link from protobuf object *opentestbed.Link
	FromProto(msg *opentestbed.Link) (Link, error)
	// FromPbText unmarshals Link from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Link from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Link from JSON text
	FromJson(value string) error
	// Validate validates Link
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Link, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Src returns LinkSrc, set in Link.
	// LinkSrc is src for the link.
	Src() LinkSrc
	// SetSrc assigns LinkSrc provided by user to Link.
	// LinkSrc is src for the link.
	SetSrc(value LinkSrc) Link
	// HasSrc checks if Src has been set in Link
	HasSrc() bool
	// Dst returns LinkDst, set in Link.
	// LinkDst is dst for the link.
	Dst() LinkDst
	// SetDst assigns LinkDst provided by user to Link.
	// LinkDst is dst for the link.
	SetDst(value LinkDst) Link
	// HasDst checks if Dst has been set in Link
	HasDst() bool
	setNil()
}

// description is TBD
// Src returns a LinkSrc
func (obj *link) Src() LinkSrc {
	if obj.obj.Src == nil {
		obj.obj.Src = NewLinkSrc().Msg()
	}
	if obj.srcHolder == nil {
		obj.srcHolder = &linkSrc{obj: obj.obj.Src}
	}
	return obj.srcHolder
}

// description is TBD
// Src returns a LinkSrc
func (obj *link) HasSrc() bool {
	return obj.obj.Src != nil
}

// description is TBD
// SetSrc sets the LinkSrc value in the Link object
func (obj *link) SetSrc(value LinkSrc) Link {

	obj.srcHolder = nil
	obj.obj.Src = value.Msg()

	return obj
}

// description is TBD
// Dst returns a LinkDst
func (obj *link) Dst() LinkDst {
	if obj.obj.Dst == nil {
		obj.obj.Dst = NewLinkDst().Msg()
	}
	if obj.dstHolder == nil {
		obj.dstHolder = &linkDst{obj: obj.obj.Dst}
	}
	return obj.dstHolder
}

// description is TBD
// Dst returns a LinkDst
func (obj *link) HasDst() bool {
	return obj.obj.Dst != nil
}

// description is TBD
// SetDst sets the LinkDst value in the Link object
func (obj *link) SetDst(value LinkDst) Link {

	obj.dstHolder = nil
	obj.obj.Dst = value.Msg()

	return obj
}

func (obj *link) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	if obj.obj.Src != nil {

		obj.Src().validateObj(vObj, set_default)
	}

	if obj.obj.Dst != nil {

		obj.Dst().validateObj(vObj, set_default)
	}

}

func (obj *link) setDefault() {

}

// ***** YieldResponse *****
type yieldResponse struct {
	validation
	obj *opentestbed.YieldResponse
}

func NewYieldResponse() YieldResponse {
	obj := yieldResponse{obj: &opentestbed.YieldResponse{}}
	obj.setDefault()
	return &obj
}

func (obj *yieldResponse) Msg() *opentestbed.YieldResponse {
	return obj.obj
}

func (obj *yieldResponse) SetMsg(msg *opentestbed.YieldResponse) YieldResponse {

	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *yieldResponse) ToProto() (*opentestbed.YieldResponse, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *yieldResponse) FromProto(msg *opentestbed.YieldResponse) (YieldResponse, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *yieldResponse) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *yieldResponse) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *yieldResponse) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *yieldResponse) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *yieldResponse) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *yieldResponse) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *yieldResponse) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *yieldResponse) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *yieldResponse) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *yieldResponse) Clone() (YieldResponse, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewYieldResponse()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// YieldResponse is output Response
type YieldResponse interface {
	Validation
	// Msg marshals YieldResponse to protobuf object *opentestbed.YieldResponse
	// and doesn't set defaults
	Msg() *opentestbed.YieldResponse
	// SetMsg unmarshals YieldResponse from protobuf object *opentestbed.YieldResponse
	// and doesn't set defaults
	SetMsg(*opentestbed.YieldResponse) YieldResponse
	// ToProto marshals YieldResponse to protobuf object *opentestbed.YieldResponse
	ToProto() (*opentestbed.YieldResponse, error)
	// ToPbText marshals YieldResponse to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals YieldResponse to YAML text
	ToYaml() (string, error)
	// ToJson marshals YieldResponse to JSON text
	ToJson() (string, error)
	// FromProto unmarshals YieldResponse from protobuf object *opentestbed.YieldResponse
	FromProto(msg *opentestbed.YieldResponse) (YieldResponse, error)
	// FromPbText unmarshals YieldResponse from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals YieldResponse from YAML text
	FromYaml(value string) error
	// FromJson unmarshals YieldResponse from JSON text
	FromJson(value string) error
	// Validate validates YieldResponse
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (YieldResponse, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Sessionid returns string, set in YieldResponse.
	Sessionid() string
	// SetSessionid assigns string provided by user to YieldResponse
	SetSessionid(value string) YieldResponse
	// HasSessionid checks if Sessionid has been set in YieldResponse
	HasSessionid() bool
	// Testbed returns string, set in YieldResponse.
	Testbed() string
	// SetTestbed assigns string provided by user to YieldResponse
	SetTestbed(value string) YieldResponse
	// HasTestbed checks if Testbed has been set in YieldResponse
	HasTestbed() bool
}

// Unique session id generated during reservation
// Sessionid returns a string
func (obj *yieldResponse) Sessionid() string {

	return *obj.obj.Sessionid

}

// Unique session id generated during reservation
// Sessionid returns a string
func (obj *yieldResponse) HasSessionid() bool {
	return obj.obj.Sessionid != nil
}

// Unique session id generated during reservation
// SetSessionid sets the string value in the YieldResponse object
func (obj *yieldResponse) SetSessionid(value string) YieldResponse {

	obj.obj.Sessionid = &value
	return obj
}

// description is TBD
// Testbed returns a string
func (obj *yieldResponse) Testbed() string {

	return *obj.obj.Testbed

}

// description is TBD
// Testbed returns a string
func (obj *yieldResponse) HasTestbed() bool {
	return obj.obj.Testbed != nil
}

// description is TBD
// SetTestbed sets the string value in the YieldResponse object
func (obj *yieldResponse) SetTestbed(value string) YieldResponse {

	obj.obj.Testbed = &value
	return obj
}

func (obj *yieldResponse) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

}

func (obj *yieldResponse) setDefault() {

}

// ***** Error *****
type _error struct {
	validation
	obj *opentestbed.Error
}

func NewError() Error {
	obj := _error{obj: &opentestbed.Error{}}
	obj.setDefault()
	return &obj
}

func (obj *_error) Msg() *opentestbed.Error {
	return obj.obj
}

func (obj *_error) SetMsg(msg *opentestbed.Error) Error {

	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *_error) ToProto() (*opentestbed.Error, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *_error) FromProto(msg *opentestbed.Error) (Error, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *_error) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *_error) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *_error) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *_error) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *_error) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *_error) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *_error) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *_error) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *_error) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *_error) Clone() (Error, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewError()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// Error is error response generated while serving API request.
type Error interface {
	Validation
	// Msg marshals Error to protobuf object *opentestbed.Error
	// and doesn't set defaults
	Msg() *opentestbed.Error
	// SetMsg unmarshals Error from protobuf object *opentestbed.Error
	// and doesn't set defaults
	SetMsg(*opentestbed.Error) Error
	// ToProto marshals Error to protobuf object *opentestbed.Error
	ToProto() (*opentestbed.Error, error)
	// ToPbText marshals Error to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Error to YAML text
	ToYaml() (string, error)
	// ToJson marshals Error to JSON text
	ToJson() (string, error)
	// FromProto unmarshals Error from protobuf object *opentestbed.Error
	FromProto(msg *opentestbed.Error) (Error, error)
	// FromPbText unmarshals Error from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Error from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Error from JSON text
	FromJson(value string) error
	// Validate validates Error
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Error, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Code returns int32, set in Error.
	Code() int32
	// SetCode assigns int32 provided by user to Error
	SetCode(value int32) Error
	// Kind returns ErrorKindEnum, set in Error
	Kind() ErrorKindEnum
	// SetKind assigns ErrorKindEnum provided by user to Error
	SetKind(value ErrorKindEnum) Error
	// HasKind checks if Kind has been set in Error
	HasKind() bool
	// Errors returns []string, set in Error.
	Errors() []string
	// SetErrors assigns []string provided by user to Error
	SetErrors(value []string) Error
	// implement Error function for implementingnative Error Interface.
	Error() string
}

func (obj *_error) Error() string {
	json, err := obj.ToJson()
	if err != nil {
		return fmt.Sprintf("could not convert Error to JSON: %v", err)
	}
	return json
}

// Numeric status code based on the underlying transport being used.
// The API server MUST set this code explicitly based on following references:
// - HTTP 4xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.5
// - HTTP 5xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.6
// - gRPC errors: https://grpc.github.io/grpc/core/md_doc_statuscodes.html
// Code returns a int32
func (obj *_error) Code() int32 {

	return *obj.obj.Code

}

// Numeric status code based on the underlying transport being used.
// The API server MUST set this code explicitly based on following references:
// - HTTP 4xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.5
// - HTTP 5xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.6
// - gRPC errors: https://grpc.github.io/grpc/core/md_doc_statuscodes.html
// SetCode sets the int32 value in the Error object
func (obj *_error) SetCode(value int32) Error {

	obj.obj.Code = &value
	return obj
}

type ErrorKindEnum string

// Enum of Kind on Error
var ErrorKind = struct {
	VALIDATION ErrorKindEnum
	INTERNAL   ErrorKindEnum
}{
	VALIDATION: ErrorKindEnum("validation"),
	INTERNAL:   ErrorKindEnum("internal"),
}

func (obj *_error) Kind() ErrorKindEnum {
	return ErrorKindEnum(obj.obj.Kind.Enum().String())
}

// Classification of error originating from within API server that may not be mapped to the value in `code`.
// Absence of this field may indicate that the error did not originate from within API server.
// Kind returns a string
func (obj *_error) HasKind() bool {
	return obj.obj.Kind != nil
}

func (obj *_error) SetKind(value ErrorKindEnum) Error {
	intValue, ok := opentestbed.Error_Kind_Enum_value[string(value)]
	if !ok {
		obj.validationErrors = append(obj.validationErrors, fmt.Sprintf(
			"%s is not a valid choice on ErrorKindEnum", string(value)))
		return obj
	}
	enumValue := opentestbed.Error_Kind_Enum(intValue)
	obj.obj.Kind = &enumValue

	return obj
}

// List of error messages generated while executing the request.
// Errors returns a []string
func (obj *_error) Errors() []string {
	if obj.obj.Errors == nil {
		obj.obj.Errors = make([]string, 0)
	}
	return obj.obj.Errors
}

// List of error messages generated while executing the request.
// SetErrors sets the []string value in the Error object
func (obj *_error) SetErrors(value []string) Error {

	if obj.obj.Errors == nil {
		obj.obj.Errors = make([]string, 0)
	}
	obj.obj.Errors = value

	return obj
}

func (obj *_error) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	// Code is required
	if obj.obj.Code == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Code is required field on interface Error")
	}
}

func (obj *_error) setDefault() {

}

// ***** Warning *****
type warning struct {
	validation
	obj *opentestbed.Warning
}

func NewWarning() Warning {
	obj := warning{obj: &opentestbed.Warning{}}
	obj.setDefault()
	return &obj
}

func (obj *warning) Msg() *opentestbed.Warning {
	return obj.obj
}

func (obj *warning) SetMsg(msg *opentestbed.Warning) Warning {

	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *warning) ToProto() (*opentestbed.Warning, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *warning) FromProto(msg *opentestbed.Warning) (Warning, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *warning) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *warning) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *warning) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *warning) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *warning) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *warning) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *warning) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *warning) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *warning) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *warning) Clone() (Warning, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewWarning()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// Warning is a list of warnings that have occurred while executing the request.
type Warning interface {
	Validation
	// Msg marshals Warning to protobuf object *opentestbed.Warning
	// and doesn't set defaults
	Msg() *opentestbed.Warning
	// SetMsg unmarshals Warning from protobuf object *opentestbed.Warning
	// and doesn't set defaults
	SetMsg(*opentestbed.Warning) Warning
	// ToProto marshals Warning to protobuf object *opentestbed.Warning
	ToProto() (*opentestbed.Warning, error)
	// ToPbText marshals Warning to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Warning to YAML text
	ToYaml() (string, error)
	// ToJson marshals Warning to JSON text
	ToJson() (string, error)
	// FromProto unmarshals Warning from protobuf object *opentestbed.Warning
	FromProto(msg *opentestbed.Warning) (Warning, error)
	// FromPbText unmarshals Warning from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Warning from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Warning from JSON text
	FromJson(value string) error
	// Validate validates Warning
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Warning, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Warnings returns []string, set in Warning.
	Warnings() []string
	// SetWarnings assigns []string provided by user to Warning
	SetWarnings(value []string) Warning
}

// A list of any system specific warnings that have occurred while
// executing the request.
// Warnings returns a []string
func (obj *warning) Warnings() []string {
	if obj.obj.Warnings == nil {
		obj.obj.Warnings = make([]string, 0)
	}
	return obj.obj.Warnings
}

// A list of any system specific warnings that have occurred while
// executing the request.
// SetWarnings sets the []string value in the Warning object
func (obj *warning) SetWarnings(value []string) Warning {

	if obj.obj.Warnings == nil {
		obj.obj.Warnings = make([]string, 0)
	}
	obj.obj.Warnings = value

	return obj
}

func (obj *warning) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

}

func (obj *warning) setDefault() {

}

// ***** Version *****
type version struct {
	validation
	obj *opentestbed.Version
}

func NewVersion() Version {
	obj := version{obj: &opentestbed.Version{}}
	obj.setDefault()
	return &obj
}

func (obj *version) Msg() *opentestbed.Version {
	return obj.obj
}

func (obj *version) SetMsg(msg *opentestbed.Version) Version {

	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *version) ToProto() (*opentestbed.Version, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *version) FromProto(msg *opentestbed.Version) (Version, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *version) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *version) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *version) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *version) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *version) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *version) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *version) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *version) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *version) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *version) Clone() (Version, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewVersion()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// Version is version details
type Version interface {
	Validation
	// Msg marshals Version to protobuf object *opentestbed.Version
	// and doesn't set defaults
	Msg() *opentestbed.Version
	// SetMsg unmarshals Version from protobuf object *opentestbed.Version
	// and doesn't set defaults
	SetMsg(*opentestbed.Version) Version
	// ToProto marshals Version to protobuf object *opentestbed.Version
	ToProto() (*opentestbed.Version, error)
	// ToPbText marshals Version to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Version to YAML text
	ToYaml() (string, error)
	// ToJson marshals Version to JSON text
	ToJson() (string, error)
	// FromProto unmarshals Version from protobuf object *opentestbed.Version
	FromProto(msg *opentestbed.Version) (Version, error)
	// FromPbText unmarshals Version from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Version from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Version from JSON text
	FromJson(value string) error
	// Validate validates Version
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Version, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// ApiSpecVersion returns string, set in Version.
	ApiSpecVersion() string
	// SetApiSpecVersion assigns string provided by user to Version
	SetApiSpecVersion(value string) Version
	// HasApiSpecVersion checks if ApiSpecVersion has been set in Version
	HasApiSpecVersion() bool
	// SdkVersion returns string, set in Version.
	SdkVersion() string
	// SetSdkVersion assigns string provided by user to Version
	SetSdkVersion(value string) Version
	// HasSdkVersion checks if SdkVersion has been set in Version
	HasSdkVersion() bool
	// AppVersion returns string, set in Version.
	AppVersion() string
	// SetAppVersion assigns string provided by user to Version
	SetAppVersion(value string) Version
	// HasAppVersion checks if AppVersion has been set in Version
	HasAppVersion() bool
}

// Version of API specification
// ApiSpecVersion returns a string
func (obj *version) ApiSpecVersion() string {

	return *obj.obj.ApiSpecVersion

}

// Version of API specification
// ApiSpecVersion returns a string
func (obj *version) HasApiSpecVersion() bool {
	return obj.obj.ApiSpecVersion != nil
}

// Version of API specification
// SetApiSpecVersion sets the string value in the Version object
func (obj *version) SetApiSpecVersion(value string) Version {

	obj.obj.ApiSpecVersion = &value
	return obj
}

// Version of SDK generated from API specification
// SdkVersion returns a string
func (obj *version) SdkVersion() string {

	return *obj.obj.SdkVersion

}

// Version of SDK generated from API specification
// SdkVersion returns a string
func (obj *version) HasSdkVersion() bool {
	return obj.obj.SdkVersion != nil
}

// Version of SDK generated from API specification
// SetSdkVersion sets the string value in the Version object
func (obj *version) SetSdkVersion(value string) Version {

	obj.obj.SdkVersion = &value
	return obj
}

// Version of application consuming or serving the API
// AppVersion returns a string
func (obj *version) AppVersion() string {

	return *obj.obj.AppVersion

}

// Version of application consuming or serving the API
// AppVersion returns a string
func (obj *version) HasAppVersion() bool {
	return obj.obj.AppVersion != nil
}

// Version of application consuming or serving the API
// SetAppVersion sets the string value in the Version object
func (obj *version) SetAppVersion(value string) Version {

	obj.obj.AppVersion = &value
	return obj
}

func (obj *version) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

}

func (obj *version) setDefault() {
	if obj.obj.ApiSpecVersion == nil {
		obj.SetApiSpecVersion("")
	}
	if obj.obj.SdkVersion == nil {
		obj.SetSdkVersion("")
	}
	if obj.obj.AppVersion == nil {
		obj.SetAppVersion("")
	}

}

// ***** Port *****
type port struct {
	validation
	obj              *opentestbed.Port
	attributesHolder PortAttributeIter
}

func NewPort() Port {
	obj := port{obj: &opentestbed.Port{}}
	obj.setDefault()
	return &obj
}

func (obj *port) Msg() *opentestbed.Port {
	return obj.obj
}

func (obj *port) SetMsg(msg *opentestbed.Port) Port {
	obj.setNil()
	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *port) ToProto() (*opentestbed.Port, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *port) FromProto(msg *opentestbed.Port) (Port, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *port) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *port) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *port) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *port) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *port) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *port) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}
	obj.setNil()
	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *port) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *port) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *port) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *port) Clone() (Port, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewPort()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

func (obj *port) setNil() {
	obj.attributesHolder = nil
	obj.validationErrors = nil
	obj.warnings = nil
	obj.constraints = make(map[string]map[string]Constraints)
}

// Port is local Port for Testbed Reservation Service.
type Port interface {
	Validation
	// Msg marshals Port to protobuf object *opentestbed.Port
	// and doesn't set defaults
	Msg() *opentestbed.Port
	// SetMsg unmarshals Port from protobuf object *opentestbed.Port
	// and doesn't set defaults
	SetMsg(*opentestbed.Port) Port
	// ToProto marshals Port to protobuf object *opentestbed.Port
	ToProto() (*opentestbed.Port, error)
	// ToPbText marshals Port to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Port to YAML text
	ToYaml() (string, error)
	// ToJson marshals Port to JSON text
	ToJson() (string, error)
	// FromProto unmarshals Port from protobuf object *opentestbed.Port
	FromProto(msg *opentestbed.Port) (Port, error)
	// FromPbText unmarshals Port from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Port from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Port from JSON text
	FromJson(value string) error
	// Validate validates Port
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Port, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Id returns string, set in Port.
	Id() string
	// SetId assigns string provided by user to Port
	SetId(value string) Port
	// Name returns string, set in Port.
	Name() string
	// SetName assigns string provided by user to Port
	SetName(value string) Port
	// HasName checks if Name has been set in Port
	HasName() bool
	// Pmd returns PortPmdEnum, set in Port
	Pmd() PortPmdEnum
	// SetPmd assigns PortPmdEnum provided by user to Port
	SetPmd(value PortPmdEnum) Port
	// HasPmd checks if Pmd has been set in Port
	HasPmd() bool
	// Speed returns PortSpeedEnum, set in Port
	Speed() PortSpeedEnum
	// SetSpeed assigns PortSpeedEnum provided by user to Port
	SetSpeed(value PortSpeedEnum) Port
	// HasSpeed checks if Speed has been set in Port
	HasSpeed() bool
	// Transceiver returns string, set in Port.
	Transceiver() string
	// SetTransceiver assigns string provided by user to Port
	SetTransceiver(value string) Port
	// HasTransceiver checks if Transceiver has been set in Port
	HasTransceiver() bool
	// Attributes returns PortAttributeIterIter, set in Port
	Attributes() PortAttributeIter
	setNil()
}

// Logical identifier for the port
// Id returns a string
func (obj *port) Id() string {

	return *obj.obj.Id

}

// Logical identifier for the port
// SetId sets the string value in the Port object
func (obj *port) SetId(value string) Port {

	obj.obj.Id = &value
	return obj
}

// Name of the port on a device that you want to match from the inventory.
// Name returns a string
func (obj *port) Name() string {

	return *obj.obj.Name

}

// Name of the port on a device that you want to match from the inventory.
// Name returns a string
func (obj *port) HasName() bool {
	return obj.obj.Name != nil
}

// Name of the port on a device that you want to match from the inventory.
// SetName sets the string value in the Port object
func (obj *port) SetName(value string) Port {

	obj.obj.Name = &value
	return obj
}

type PortPmdEnum string

// Enum of Pmd on Port
var PortPmd = struct {
	PMD_UNSPECIFIED    PortPmdEnum
	PMD_10GBASE_LRM    PortPmdEnum
	PMD_10GBASE_LR     PortPmdEnum
	PMD_10GBASE_ZR     PortPmdEnum
	PMD_10GBASE_ER     PortPmdEnum
	PMD_10GBASE_SR     PortPmdEnum
	PMD_40GBASE_CR4    PortPmdEnum
	PMD_40GBASE_SR4    PortPmdEnum
	PMD_40GBASE_LR4    PortPmdEnum
	PMD_40GBASE_ER4    PortPmdEnum
	PMD_40GBASE_PSM4   PortPmdEnum
	PMD_4X10GBASE_LR   PortPmdEnum
	PMD_4X10GBASE_SR   PortPmdEnum
	PMD_100G_AOC       PortPmdEnum
	PMD_100G_ACC       PortPmdEnum
	PMD_100GBASE_SR10  PortPmdEnum
	PMD_100GBASE_SR4   PortPmdEnum
	PMD_100GBASE_LR4   PortPmdEnum
	PMD_100GBASE_ER4   PortPmdEnum
	PMD_100GBASE_CWDM4 PortPmdEnum
	PMD_100GBASE_CLR4  PortPmdEnum
	PMD_100GBASE_PSM4  PortPmdEnum
	PMD_100GBASE_CR4   PortPmdEnum
	PMD_100GBASE_FR    PortPmdEnum
	PMD_400GBASE_ZR    PortPmdEnum
	PMD_400GBASE_LR4   PortPmdEnum
	PMD_400GBASE_FR4   PortPmdEnum
	PMD_400GBASE_LR8   PortPmdEnum
	PMD_400GBASE_DR4   PortPmdEnum
	PMD_100GBASE_DR    PortPmdEnum
}{
	PMD_UNSPECIFIED:    PortPmdEnum("PMD_UNSPECIFIED"),
	PMD_10GBASE_LRM:    PortPmdEnum("PMD_10GBASE_LRM"),
	PMD_10GBASE_LR:     PortPmdEnum("PMD_10GBASE_LR"),
	PMD_10GBASE_ZR:     PortPmdEnum("PMD_10GBASE_ZR"),
	PMD_10GBASE_ER:     PortPmdEnum("PMD_10GBASE_ER"),
	PMD_10GBASE_SR:     PortPmdEnum("PMD_10GBASE_SR"),
	PMD_40GBASE_CR4:    PortPmdEnum("PMD_40GBASE_CR4"),
	PMD_40GBASE_SR4:    PortPmdEnum("PMD_40GBASE_SR4"),
	PMD_40GBASE_LR4:    PortPmdEnum("PMD_40GBASE_LR4"),
	PMD_40GBASE_ER4:    PortPmdEnum("PMD_40GBASE_ER4"),
	PMD_40GBASE_PSM4:   PortPmdEnum("PMD_40GBASE_PSM4"),
	PMD_4X10GBASE_LR:   PortPmdEnum("PMD_4X10GBASE_LR"),
	PMD_4X10GBASE_SR:   PortPmdEnum("PMD_4X10GBASE_SR"),
	PMD_100G_AOC:       PortPmdEnum("PMD_100G_AOC"),
	PMD_100G_ACC:       PortPmdEnum("PMD_100G_ACC"),
	PMD_100GBASE_SR10:  PortPmdEnum("PMD_100GBASE_SR10"),
	PMD_100GBASE_SR4:   PortPmdEnum("PMD_100GBASE_SR4"),
	PMD_100GBASE_LR4:   PortPmdEnum("PMD_100GBASE_LR4"),
	PMD_100GBASE_ER4:   PortPmdEnum("PMD_100GBASE_ER4"),
	PMD_100GBASE_CWDM4: PortPmdEnum("PMD_100GBASE_CWDM4"),
	PMD_100GBASE_CLR4:  PortPmdEnum("PMD_100GBASE_CLR4"),
	PMD_100GBASE_PSM4:  PortPmdEnum("PMD_100GBASE_PSM4"),
	PMD_100GBASE_CR4:   PortPmdEnum("PMD_100GBASE_CR4"),
	PMD_100GBASE_FR:    PortPmdEnum("PMD_100GBASE_FR"),
	PMD_400GBASE_ZR:    PortPmdEnum("PMD_400GBASE_ZR"),
	PMD_400GBASE_LR4:   PortPmdEnum("PMD_400GBASE_LR4"),
	PMD_400GBASE_FR4:   PortPmdEnum("PMD_400GBASE_FR4"),
	PMD_400GBASE_LR8:   PortPmdEnum("PMD_400GBASE_LR8"),
	PMD_400GBASE_DR4:   PortPmdEnum("PMD_400GBASE_DR4"),
	PMD_100GBASE_DR:    PortPmdEnum("PMD_100GBASE_DR"),
}

func (obj *port) Pmd() PortPmdEnum {
	return PortPmdEnum(obj.obj.Pmd.Enum().String())
}

// Physical medium dependent of the port.
// This should be kept in sync with the values specified in OpenConfig:
// https://github.com/openconfig/public/blob/master/release/models/optical-transport/openconfig-transport-types.yang
// Pmd returns a string
func (obj *port) HasPmd() bool {
	return obj.obj.Pmd != nil
}

func (obj *port) SetPmd(value PortPmdEnum) Port {
	intValue, ok := opentestbed.Port_Pmd_Enum_value[string(value)]
	if !ok {
		obj.validationErrors = append(obj.validationErrors, fmt.Sprintf(
			"%s is not a valid choice on PortPmdEnum", string(value)))
		return obj
	}
	enumValue := opentestbed.Port_Pmd_Enum(intValue)
	obj.obj.Pmd = &enumValue

	return obj
}

type PortSpeedEnum string

// Enum of Speed on Port
var PortSpeed = struct {
	SPEED_UNSPECIFIED PortSpeedEnum
	S_1GB             PortSpeedEnum
	S_5GB             PortSpeedEnum
	S_10GB            PortSpeedEnum
	S_25GB            PortSpeedEnum
	S_40GB            PortSpeedEnum
	S_50GB            PortSpeedEnum
	S_100GB           PortSpeedEnum
	S_200GB           PortSpeedEnum
	S_400GB           PortSpeedEnum
}{
	SPEED_UNSPECIFIED: PortSpeedEnum("SPEED_UNSPECIFIED"),
	S_1GB:             PortSpeedEnum("S_1GB"),
	S_5GB:             PortSpeedEnum("S_5GB"),
	S_10GB:            PortSpeedEnum("S_10GB"),
	S_25GB:            PortSpeedEnum("S_25GB"),
	S_40GB:            PortSpeedEnum("S_40GB"),
	S_50GB:            PortSpeedEnum("S_50GB"),
	S_100GB:           PortSpeedEnum("S_100GB"),
	S_200GB:           PortSpeedEnum("S_200GB"),
	S_400GB:           PortSpeedEnum("S_400GB"),
}

func (obj *port) Speed() PortSpeedEnum {
	return PortSpeedEnum(obj.obj.Speed.Enum().String())
}

// description is TBD
// Speed returns a string
func (obj *port) HasSpeed() bool {
	return obj.obj.Speed != nil
}

func (obj *port) SetSpeed(value PortSpeedEnum) Port {
	intValue, ok := opentestbed.Port_Speed_Enum_value[string(value)]
	if !ok {
		obj.validationErrors = append(obj.validationErrors, fmt.Sprintf(
			"%s is not a valid choice on PortSpeedEnum", string(value)))
		return obj
	}
	enumValue := opentestbed.Port_Speed_Enum(intValue)
	obj.obj.Speed = &enumValue

	return obj
}

// description is TBD
// Transceiver returns a string
func (obj *port) Transceiver() string {

	return *obj.obj.Transceiver

}

// description is TBD
// Transceiver returns a string
func (obj *port) HasTransceiver() bool {
	return obj.obj.Transceiver != nil
}

// description is TBD
// SetTransceiver sets the string value in the Port object
func (obj *port) SetTransceiver(value string) Port {

	obj.obj.Transceiver = &value
	return obj
}

// attributes of the device ports that specify an internal architecture behind the port, for example: NPU #, NPU Core, Slice #,
// Attributes returns a []Attribute
func (obj *port) Attributes() PortAttributeIter {
	if len(obj.obj.Attributes) == 0 {
		obj.obj.Attributes = []*opentestbed.Attribute{}
	}
	if obj.attributesHolder == nil {
		obj.attributesHolder = newPortAttributeIter(&obj.obj.Attributes).setMsg(obj)
	}
	return obj.attributesHolder
}

type portAttributeIter struct {
	obj            *port
	attributeSlice []Attribute
	fieldPtr       *[]*opentestbed.Attribute
}

func newPortAttributeIter(ptr *[]*opentestbed.Attribute) PortAttributeIter {
	return &portAttributeIter{fieldPtr: ptr}
}

type PortAttributeIter interface {
	setMsg(*port) PortAttributeIter
	Items() []Attribute
	Add() Attribute
	Append(items ...Attribute) PortAttributeIter
	Set(index int, newObj Attribute) PortAttributeIter
	Clear() PortAttributeIter
	clearHolderSlice() PortAttributeIter
	appendHolderSlice(item Attribute) PortAttributeIter
}

func (obj *portAttributeIter) setMsg(msg *port) PortAttributeIter {
	obj.clearHolderSlice()
	for _, val := range *obj.fieldPtr {
		obj.appendHolderSlice(&attribute{obj: val})
	}
	obj.obj = msg
	return obj
}

func (obj *portAttributeIter) Items() []Attribute {
	return obj.attributeSlice
}

func (obj *portAttributeIter) Add() Attribute {
	newObj := &opentestbed.Attribute{}
	*obj.fieldPtr = append(*obj.fieldPtr, newObj)
	newLibObj := &attribute{obj: newObj}
	newLibObj.setDefault()
	obj.attributeSlice = append(obj.attributeSlice, newLibObj)
	return newLibObj
}

func (obj *portAttributeIter) Append(items ...Attribute) PortAttributeIter {
	for _, item := range items {
		newObj := item.Msg()
		*obj.fieldPtr = append(*obj.fieldPtr, newObj)
		obj.attributeSlice = append(obj.attributeSlice, item)
	}
	return obj
}

func (obj *portAttributeIter) Set(index int, newObj Attribute) PortAttributeIter {
	(*obj.fieldPtr)[index] = newObj.Msg()
	obj.attributeSlice[index] = newObj
	return obj
}
func (obj *portAttributeIter) Clear() PortAttributeIter {
	if len(*obj.fieldPtr) > 0 {
		*obj.fieldPtr = []*opentestbed.Attribute{}
		obj.attributeSlice = []Attribute{}
	}
	return obj
}
func (obj *portAttributeIter) clearHolderSlice() PortAttributeIter {
	if len(obj.attributeSlice) > 0 {
		obj.attributeSlice = []Attribute{}
	}
	return obj
}
func (obj *portAttributeIter) appendHolderSlice(item Attribute) PortAttributeIter {
	obj.attributeSlice = append(obj.attributeSlice, item)
	return obj
}

func (obj *port) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	// Id is required
	if obj.obj.Id == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Id is required field on interface Port")
	}

	if len(obj.obj.Attributes) != 0 {

		if set_default {
			obj.Attributes().clearHolderSlice()
			for _, item := range obj.obj.Attributes {
				obj.Attributes().appendHolderSlice(&attribute{obj: item})
			}
		}
		for _, item := range obj.Attributes().Items() {
			item.validateObj(vObj, set_default)
		}

	}

}

func (obj *port) setDefault() {
	if obj.obj.Pmd == nil {
		obj.SetPmd(PortPmd.PMD_UNSPECIFIED)

	}
	if obj.obj.Speed == nil {
		obj.SetSpeed(PortSpeed.SPEED_UNSPECIFIED)

	}

}

// ***** Attribute *****
type attribute struct {
	validation
	obj *opentestbed.Attribute
}

func NewAttribute() Attribute {
	obj := attribute{obj: &opentestbed.Attribute{}}
	obj.setDefault()
	return &obj
}

func (obj *attribute) Msg() *opentestbed.Attribute {
	return obj.obj
}

func (obj *attribute) SetMsg(msg *opentestbed.Attribute) Attribute {

	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *attribute) ToProto() (*opentestbed.Attribute, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *attribute) FromProto(msg *opentestbed.Attribute) (Attribute, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *attribute) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *attribute) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *attribute) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *attribute) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *attribute) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *attribute) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *attribute) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *attribute) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *attribute) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *attribute) Clone() (Attribute, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewAttribute()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// Attribute is attributes of the device ports that specify an internal architecture behind the port, for example: NPU #, NPU Core, Slice #
type Attribute interface {
	Validation
	// Msg marshals Attribute to protobuf object *opentestbed.Attribute
	// and doesn't set defaults
	Msg() *opentestbed.Attribute
	// SetMsg unmarshals Attribute from protobuf object *opentestbed.Attribute
	// and doesn't set defaults
	SetMsg(*opentestbed.Attribute) Attribute
	// ToProto marshals Attribute to protobuf object *opentestbed.Attribute
	ToProto() (*opentestbed.Attribute, error)
	// ToPbText marshals Attribute to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals Attribute to YAML text
	ToYaml() (string, error)
	// ToJson marshals Attribute to JSON text
	ToJson() (string, error)
	// FromProto unmarshals Attribute from protobuf object *opentestbed.Attribute
	FromProto(msg *opentestbed.Attribute) (Attribute, error)
	// FromPbText unmarshals Attribute from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals Attribute from YAML text
	FromYaml(value string) error
	// FromJson unmarshals Attribute from JSON text
	FromJson(value string) error
	// Validate validates Attribute
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (Attribute, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Key returns string, set in Attribute.
	Key() string
	// SetKey assigns string provided by user to Attribute
	SetKey(value string) Attribute
	// HasKey checks if Key has been set in Attribute
	HasKey() bool
	// Value returns string, set in Attribute.
	Value() string
	// SetValue assigns string provided by user to Attribute
	SetValue(value string) Attribute
	// HasValue checks if Value has been set in Attribute
	HasValue() bool
}

// Globally unique name of an object. It also serves as the primary key for arrays of objects.
// Key returns a string
func (obj *attribute) Key() string {

	return *obj.obj.Key

}

// Globally unique name of an object. It also serves as the primary key for arrays of objects.
// Key returns a string
func (obj *attribute) HasKey() bool {
	return obj.obj.Key != nil
}

// Globally unique name of an object. It also serves as the primary key for arrays of objects.
// SetKey sets the string value in the Attribute object
func (obj *attribute) SetKey(value string) Attribute {

	obj.obj.Key = &value
	return obj
}

// description is TBD
// Value returns a string
func (obj *attribute) Value() string {

	return *obj.obj.Value

}

// description is TBD
// Value returns a string
func (obj *attribute) HasValue() bool {
	return obj.obj.Value != nil
}

// description is TBD
// SetValue sets the string value in the Attribute object
func (obj *attribute) SetValue(value string) Attribute {

	obj.obj.Value = &value
	return obj
}

func (obj *attribute) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

}

func (obj *attribute) setDefault() {

}

// ***** LinkSrc *****
type linkSrc struct {
	validation
	obj *opentestbed.LinkSrc
}

func NewLinkSrc() LinkSrc {
	obj := linkSrc{obj: &opentestbed.LinkSrc{}}
	obj.setDefault()
	return &obj
}

func (obj *linkSrc) Msg() *opentestbed.LinkSrc {
	return obj.obj
}

func (obj *linkSrc) SetMsg(msg *opentestbed.LinkSrc) LinkSrc {

	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *linkSrc) ToProto() (*opentestbed.LinkSrc, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *linkSrc) FromProto(msg *opentestbed.LinkSrc) (LinkSrc, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *linkSrc) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *linkSrc) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *linkSrc) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *linkSrc) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *linkSrc) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *linkSrc) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *linkSrc) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *linkSrc) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *linkSrc) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *linkSrc) Clone() (LinkSrc, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewLinkSrc()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// LinkSrc is src for the link.
type LinkSrc interface {
	Validation
	// Msg marshals LinkSrc to protobuf object *opentestbed.LinkSrc
	// and doesn't set defaults
	Msg() *opentestbed.LinkSrc
	// SetMsg unmarshals LinkSrc from protobuf object *opentestbed.LinkSrc
	// and doesn't set defaults
	SetMsg(*opentestbed.LinkSrc) LinkSrc
	// ToProto marshals LinkSrc to protobuf object *opentestbed.LinkSrc
	ToProto() (*opentestbed.LinkSrc, error)
	// ToPbText marshals LinkSrc to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals LinkSrc to YAML text
	ToYaml() (string, error)
	// ToJson marshals LinkSrc to JSON text
	ToJson() (string, error)
	// FromProto unmarshals LinkSrc from protobuf object *opentestbed.LinkSrc
	FromProto(msg *opentestbed.LinkSrc) (LinkSrc, error)
	// FromPbText unmarshals LinkSrc from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals LinkSrc from YAML text
	FromYaml(value string) error
	// FromJson unmarshals LinkSrc from JSON text
	FromJson(value string) error
	// Validate validates LinkSrc
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (LinkSrc, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Device returns string, set in LinkSrc.
	Device() string
	// SetDevice assigns string provided by user to LinkSrc
	SetDevice(value string) LinkSrc
	// Port returns string, set in LinkSrc.
	Port() string
	// SetPort assigns string provided by user to LinkSrc
	SetPort(value string) LinkSrc
}

// The unique id of a logical device
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// Device returns a string
func (obj *linkSrc) Device() string {

	return *obj.obj.Device

}

// The unique id of a logical device
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// SetDevice sets the string value in the LinkSrc object
func (obj *linkSrc) SetDevice(value string) LinkSrc {

	obj.obj.Device = &value
	return obj
}

// The id of a logical port of a device
//
// x-constraint:
// - /components/schemas/Port/properties/id
//
// Port returns a string
func (obj *linkSrc) Port() string {

	return *obj.obj.Port

}

// The id of a logical port of a device
//
// x-constraint:
// - /components/schemas/Port/properties/id
//
// SetPort sets the string value in the LinkSrc object
func (obj *linkSrc) SetPort(value string) LinkSrc {

	obj.obj.Port = &value
	return obj
}

func (obj *linkSrc) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	// Device is required
	if obj.obj.Device == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Device is required field on interface LinkSrc")
	}

	// Port is required
	if obj.obj.Port == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Port is required field on interface LinkSrc")
	}
}

func (obj *linkSrc) setDefault() {

}

// ***** LinkDst *****
type linkDst struct {
	validation
	obj *opentestbed.LinkDst
}

func NewLinkDst() LinkDst {
	obj := linkDst{obj: &opentestbed.LinkDst{}}
	obj.setDefault()
	return &obj
}

func (obj *linkDst) Msg() *opentestbed.LinkDst {
	return obj.obj
}

func (obj *linkDst) SetMsg(msg *opentestbed.LinkDst) LinkDst {

	proto.Merge(obj.obj, msg)
	return obj
}

func (obj *linkDst) ToProto() (*opentestbed.LinkDst, error) {
	err := obj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return obj.Msg(), nil
}

func (obj *linkDst) FromProto(msg *opentestbed.LinkDst) (LinkDst, error) {
	newObj := obj.SetMsg(msg)
	err := newObj.validateToAndFrom()
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

func (obj *linkDst) ToPbText() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	protoMarshal, err := proto.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(protoMarshal), nil
}

func (obj *linkDst) FromPbText(value string) error {
	retObj := proto.Unmarshal([]byte(value), obj.Msg())
	if retObj != nil {
		return retObj
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return retObj
}

func (obj *linkDst) ToYaml() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	data, err = yaml.JSONToYAML(data)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *linkDst) FromYaml(value string) error {
	if value == "" {
		value = "{}"
	}
	data, err := yaml.YAMLToJSON([]byte(value))
	if err != nil {
		return err
	}
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	uError := opts.Unmarshal([]byte(data), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return vErr
	}
	return nil
}

func (obj *linkDst) ToJson() (string, error) {
	vErr := obj.validateToAndFrom()
	if vErr != nil {
		return "", vErr
	}
	opts := protojson.MarshalOptions{
		UseProtoNames:   true,
		AllowPartial:    true,
		EmitUnpopulated: false,
		Indent:          "  ",
	}
	data, err := opts.Marshal(obj.Msg())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (obj *linkDst) FromJson(value string) error {
	opts := protojson.UnmarshalOptions{
		AllowPartial:   true,
		DiscardUnknown: false,
	}
	if value == "" {
		value = "{}"
	}
	uError := opts.Unmarshal([]byte(value), obj.Msg())
	if uError != nil {
		return fmt.Errorf("unmarshal error %s", strings.Replace(
			uError.Error(), "\u00a0", " ", -1)[7:])
	}

	err := obj.validateToAndFrom()
	if err != nil {
		return err
	}
	return nil
}

func (obj *linkDst) validateToAndFrom() error {
	// emptyVars()
	obj.validateObj(&obj.validation, true)
	return obj.validationResult()
}

func (obj *linkDst) Validate() error {
	// emptyVars()
	obj.validateObj(&obj.validation, false)
	return obj.validationResult()
}

func (obj *linkDst) String() string {
	str, err := obj.ToYaml()
	if err != nil {
		return err.Error()
	}
	return str
}

func (obj *linkDst) Clone() (LinkDst, error) {
	vErr := obj.Validate()
	if vErr != nil {
		return nil, vErr
	}
	newObj := NewLinkDst()
	data, err := proto.Marshal(obj.Msg())
	if err != nil {
		return nil, err
	}
	pbErr := proto.Unmarshal(data, newObj.Msg())
	if pbErr != nil {
		return nil, pbErr
	}
	return newObj, nil
}

// LinkDst is dst for the link.
type LinkDst interface {
	Validation
	// Msg marshals LinkDst to protobuf object *opentestbed.LinkDst
	// and doesn't set defaults
	Msg() *opentestbed.LinkDst
	// SetMsg unmarshals LinkDst from protobuf object *opentestbed.LinkDst
	// and doesn't set defaults
	SetMsg(*opentestbed.LinkDst) LinkDst
	// ToProto marshals LinkDst to protobuf object *opentestbed.LinkDst
	ToProto() (*opentestbed.LinkDst, error)
	// ToPbText marshals LinkDst to protobuf text
	ToPbText() (string, error)
	// ToYaml marshals LinkDst to YAML text
	ToYaml() (string, error)
	// ToJson marshals LinkDst to JSON text
	ToJson() (string, error)
	// FromProto unmarshals LinkDst from protobuf object *opentestbed.LinkDst
	FromProto(msg *opentestbed.LinkDst) (LinkDst, error)
	// FromPbText unmarshals LinkDst from protobuf text
	FromPbText(value string) error
	// FromYaml unmarshals LinkDst from YAML text
	FromYaml(value string) error
	// FromJson unmarshals LinkDst from JSON text
	FromJson(value string) error
	// Validate validates LinkDst
	Validate() error
	// A stringer function
	String() string
	// Clones the object
	Clone() (LinkDst, error)
	validateToAndFrom() error
	validateObj(vObj *validation, set_default bool)
	setDefault()
	// Device returns string, set in LinkDst.
	Device() string
	// SetDevice assigns string provided by user to LinkDst
	SetDevice(value string) LinkDst
	// Port returns string, set in LinkDst.
	Port() string
	// SetPort assigns string provided by user to LinkDst
	SetPort(value string) LinkDst
}

// The unique id of a logical device
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// Device returns a string
func (obj *linkDst) Device() string {

	return *obj.obj.Device

}

// The unique id of a logical device
//
// x-constraint:
// - /components/schemas/Device/properties/id
//
// SetDevice sets the string value in the LinkDst object
func (obj *linkDst) SetDevice(value string) LinkDst {

	obj.obj.Device = &value
	return obj
}

// The id of a logical port of a device
//
// x-constraint:
// - /components/schemas/port/properties/id
//
// Port returns a string
func (obj *linkDst) Port() string {

	return *obj.obj.Port

}

// The id of a logical port of a device
//
// x-constraint:
// - /components/schemas/port/properties/id
//
// SetPort sets the string value in the LinkDst object
func (obj *linkDst) SetPort(value string) LinkDst {

	obj.obj.Port = &value
	return obj
}

func (obj *linkDst) validateObj(vObj *validation, set_default bool) {
	if set_default {
		obj.setDefault()
	}

	// Device is required
	if obj.obj.Device == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Device is required field on interface LinkDst")
	}

	// Port is required
	if obj.obj.Port == nil {
		vObj.validationErrors = append(vObj.validationErrors, "Port is required field on interface LinkDst")
	}
}

func (obj *linkDst) setDefault() {

}
